[{"categories":["DataStructure"],"content":"本文主要介绍了线段树的基本操作，并以区间和为例对其更新和查询做了详细介绍。","date":"2022-03-11","objectID":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["DataStructure"],"content":"写在前面 本文主要参考了 Pecco的知乎专栏，并在线段树概念介面增加了更多笔墨和证明，期望能给后续自身复习和他人学习带来更多帮助。由于个人疏于 C++ 语言，因此重新使用 Java 语言进行了实现。 ","date":"2022-03-11","objectID":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/:1:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["DataStructure"],"content":"线段树介绍 线段树（Segment Tree）是一种主要用于维护区间信息（要求满足结合律）的数据结构，它支持 $O(logn) $复杂度的区间修改和 $O(logn)$ 复杂度的区间查询。 线段树的每个节点都对应一条线段（区间）的某种运算结果（通常是乘积或加和，下面均以加和为例），其中根节点对应整个区间的和。对于某个非叶子节点 $node[left, right]$，其左右子节点对应区间可表示如下： $node.left[left, mid]$ $node.right[mid + 1, right]$ $mid = \\lfloor{(left + right) / 2)}\\rfloor{} \\ or \\ \\lfloor{(left + right + 1) / 2}\\rfloor{} - 1$ 为了更加直观，这里以区间 $[1, 5]$ 为例，对两种不同划分情况建立的线段树进行可视化： 方式一 方式二 可以看出线段树所有节点的左右子树高度差至多为1，因此线段树是一颗平衡二叉树。 接下来我们探讨线段树的存储方式。通常我们会将线段树存储在数组里，那么对于长度为 $n$ 的原数组，存储它的数组的大小应当为多少？ 答案是至少为 $2n - 1$，至多为 $4n - 5$。让我们来简单证明下。 对于一颗线段树，其叶子节点的数量为 $n$，因此其非叶子节点的数量为 $n - 1$，你可以很容易证明它，因为线段树的非叶子节点要么没有子节点，要么左右节点都不为空。所以存储线段树的数组大小至少为 $2n - 1$。 $$ n_0 + n_1 + n_2 = 2n_2 + n_1 + 1 -\u003e n_2 = n_0 - 1 = n - 1 $$ 但考虑如方式二种所示情况，因为使用数组存储，所以最后一层中为空的节点同样需要消耗数组空间。此时线段树的倒数第二层的节点数量为 $n - 2 + 1 = n - 1$，因此最后一层为空的节点数为 $2(n - 1) - 2 = 2n - 4$，所以整个数组的大小为 $2n - 4 + 2n - 1 = 4n - 5$。 而容易得知方式二就是最快的情况，所以一般建立线段树数组时需要开辟 $4n$ 的存储空间。 ","date":"2022-03-11","objectID":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/:2:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["DataStructure"],"content":"线段树的建立 那么如何从数组中建立一棵线段树？我们可以考虑递归地进行。假设输入数组为 $nums$， 长度为 $n$。 int[] tree = new int[4 * n]; // left, right为输入数组的左右区间点，p为待建立线段树的节点下标 public void build(int left, int right, int p){ // 叶子节点 if(left == right){ tree[p] = nums[left]; }else{ int mid = left + (right - left \u003e\u003e 1); // 先建立左右节点 build(left, mid, p * 2 + 1); build(mid + 1, right, p * 2 + 2); // 该节点的和等于左右节点的和 tree[p] = tree[p * 2 + 1] + tree[p * 2 + 2]; } } 这里是一张来自网上的 $gif$ 图，它描述了对 $[1,2,3,4,5]$ 建立线段树的过程： ","date":"2022-03-11","objectID":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/:3:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["DataStructure"],"content":"线段树的修改 仿照线段树的建立，我们也可以采用递归的方式进行修改，但这样的时间复杂度会比较高。而通常则会引入懒标记来加速这一过程，这也是线段树的精髓所在。使用懒标记后，对于恰好是线段树非叶子节点的那些区间，我们不再递归下去，而是打上一个标记，等到将来要用到它的子区间时，再向下传递。假设需要修改的区间为$[left, right]$，修改的量为 $d$，那么修改过程可以表示为： int[] mark = new int[4 * n]; public void update(int left, int right, int d){ update(left, right, d, 0, 0, n - 1); } // cLeft, cRight代表当前要修改的线段树区间 public void update(int left, int right, int d, int p, int cLeft, int cRight){ // 修改区间不包含线段树区间 if(left \u003e cRight || right \u003c cLeft){ return; }else if(cLeft \u003e= left \u0026\u0026 right \u003e= cRight){ // 修改区间完全覆盖线段树区间 tree[p] += (cRight - cLeft + 1) * d; // 直接修改对应区间值 if(cLeft != cRight){ // 并给非叶子节点打上标记 mark[p] += d; } }else{ // 修改区间与线段树区间存在重叠，则二分递归地修改 int mid = cLeft + (cRight - cLeft \u003e\u003e 1); mark[p * 2 + 1] += mark[p]; // 将当前节点的标记分发给其子节点 mark[p * 2 + 2] += mark[p]; tree[p * 2 + 1] += mark[p] * (mid - cLeft + 1); // 子节点的值叠加父节点的标记量 tree[p * 2 + 2] += mark[p] * (cRight - mid); mark[p] = 0; // 因为已经把懒标记给了子节点，所以本身的标记置0 } } 有同学可能会疑惑这个更新操作在修改区间完全覆盖线段树区间时没有更新整个线段树，但其实我们后续查询的过程中也会根据懒标记对节点值更新，所以不必担忧。 下面是一段为上面建立的线段树的区间 $[1,4]$ 加上 1 的过程： 实际上，对于上段更新部分 $18 \\to 22$ 部分的代码，由于后续查询部分同样要用到，所以通常会额外封装成另一个函数 $push_down$，其代码为： private void push_down(int p, int cLeft, int mid, int cRight){ mark[p * 2 + 1] += mark[p]; mark[p * 2 + 2] += mark[p]; tree[p * 2 + 1] += mark[p] * (mid - cLeft + 1); tree[p * 2 + 2] += mark[p] * (cRight - mid); mark[p] = 0; } ","date":"2022-03-11","objectID":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/:4:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["DataStructure"],"content":"线段树的查询 有了线段树的修改部分的经验，我们同样可以利用懒标记很快地写出查询部分的代码如下： public int query(int left, int right){ return query(left, right, 0, 0, n - 1); } private int query(int left, int right, int p, int cLeft, int cRight){ // 查询区间不包含线段树区间 if(left \u003e cRight || right \u003c cLeft){ return 0; }else if(cLeft \u003e= left \u0026\u0026 cRight \u003c= right){ // 查询区间恰好覆盖线段树区间 return tree[p]; }else{ // 查询区间与线段树区间存在重叠，则二分查询，同时记得跟新懒标记 int mid = cLeft + (cRight - cLeft \u003e\u003e\u003e 1); push_down(p, cLeft, mid, cRight); return query(left, right, p * 2 + 1, cLeft, mid) + query(left, right, p * 2 + 2, mid + 1, cRight); } } ","date":"2022-03-11","objectID":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/:5:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":["DataStructure"],"content":"结语 本文仅介绍了最基本的线段树用法，其实线段树的题目千奇百怪，而且技巧极多。在维护不同的信息时，需要注意是否需要乘区间长度、不同的标记之间是否相互影响等。下面附上用于区间和的线段树模板： class SegmentTree { private final int[] tree; private final int[] mark; private final int n; public SegmentTree(int[] nums){ n = nums.length; tree = new int[n \u003c\u003c 2]; Arrays.fill(tree, Integer.MIN_VALUE); build(nums, 0, nums.length - 1, 0); mark = new int[n \u003c\u003c 2]; } private void build(int[] nums, int left, int right, int p){ if(left == right){ tree[p] = nums[left]; }else{ int mid = (left + right) / 2; build(nums, left, mid, p * 2 + 1); build(nums, mid + 1, right, p * 2 + 2); tree[p] = tree[p * 2 + 1] + tree[p * 2 + 2]; } } public void update(int left, int right, int d){ update(left, right, d, 0, 0, n - 1); } private void update(int left, int right, int d, int p, int cLeft, int cRight){ if(cLeft \u003e right || cRight \u003c left){ return; }else if(cLeft \u003e= left \u0026\u0026 cRight \u003c= right){ tree[p] += (cRight - cLeft + 1) * d; if(cLeft \u003c cRight){ mark[p] += 1; } }else{ int mid = cLeft + (cRight - cLeft \u003e\u003e\u003e 1); push_down(p, cLeft, mid, cRight); update(left, right, d, p * 2 + 1, cLeft, mid); update(left, right, d, p * 2 + 2, mid + 1, cRight); tree[p] = tree[p * 2 + 1] + tree[p * 2 + 2]; } } public int query(int left, int right){ return query(left, right, 0, 0, n - 1); } private int query(int left, int right, int p, int cLeft, int cRight){ if(left \u003e cRight || right \u003c cLeft){ return 0; }else if(cLeft \u003e= left \u0026\u0026 cRight \u003c= right){ return tree[p]; }else{ int mid = cLeft + (cRight - cLeft \u003e\u003e\u003e 1); push_down(p, cLeft, mid, cRight); return query(left, right, p * 2 + 1, cLeft, mid) + query(left, right, p * 2 + 2, mid + 1, cRight); } } private void push_down(int p, int cLeft, int mid, int cRight){ mark[p * 2 + 1] += mark[p]; mark[p * 2 + 2] += mark[p]; tree[p * 2 + 1] += mark[p] * (mid - cLeft + 1); tree[p * 2 + 2] += mark[p] * (cRight - mid); mark[p] = 0; } } 实际上线段树还可以维护区间最值、区间 $gcd$ 等等，操作除了区间加也可以是区间乘、区间赋值，了解原理后很容易改。 ","date":"2022-03-11","objectID":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/:6:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/%E5%88%9D%E8%AF%86%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"categories":null,"content":"关于我 一个普通的小镇青年，有幸拥有普通的智力和普通而温馨的家庭，互联网萌新，业余日语翻译。 ","date":"2022-03-08","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"关于本站 不求成为多有含量的技术博客，仅是分享自身的学习经验，期望能解答部分你遇到的难题。 ","date":"2022-03-08","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Course"],"content":"本文简要介绍了如何利用 GitHub Actions 来自动化 Hugo 博客的部署。","date":"2022-03-08","objectID":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Course"],"content":"前置准备 在部署 Hugo 博客前，我们首先需要有一个 Hugo 博客，因此需要预先安装 Hugo、 Go（Go 是 Hugo 的运行依赖）和 Git（用于版本管理，你也可以选择其他 SVN）。 ","date":"2022-03-08","objectID":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/:1:0","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Course"],"content":"Go 和 Git 的安装 Go官网 和 Git官网下载安装包后一直点下一步即可。 ","date":"2022-03-08","objectID":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/:1:1","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Course"],"content":"Hugo 的安装 官方发布处选择适合你电脑的版本下载，需要注意的是有些 Hugo 主题需要 Hugo_extended 才能使用。 对于 Windows 用户，下载下来的压缩包解压后仅包含 License 文件、ReadMe 和一个可执行文件。为了方便起见，我们可以将其所在的文件夹路径添加系统变量的 Path 变量中，这样即可直接在 cmd 中使用 hugo xxx 命令。 ","date":"2022-03-08","objectID":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/:1:2","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Course"],"content":"搭建博客 ","date":"2022-03-08","objectID":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/:2:0","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Course"],"content":"Hugo 简单命令 首先介绍几个简单的 Hugo 命令，更多信息可参考官方文档。 hugo new site dst 该命令会在 dst 处新建一个 Hugo 博客工程文件，dst 为 . 时则会在当前路径新建。需要注意的是，当 dst 对应路径的文件夹已存在，Hugo 会报错并提示你在命令中增加 -force 参数来强制创建，此时按照提示添加即可创建成功。新建的 Hugo 博客工程文件夹下应该类似下图： 刚完成配置的Hugo文件夹 ├── config.toml 总配置文件，可以在里面更改各类配置 ├── archetypes 文章原型 │ └── default.md ├── content 存放文章内容的文件夹 ├── data ├── layouts 布局相关文件 ├── static 用于存放你在 content 中的文章会用到的图片等资料 ├── public 渲染出来的文章会放在该文件夹下 └── themes 用于存放 Hugo 的主题 hugo new dst 该命令会在 content 文件夹下创建 dst 文章，一般该文件应当以 .md 结尾，同时根据语言类型在正式文件名和后缀名间加上语言代号以方便后期管理，例如 post.zh-cn.md。dst 也可以是多级相对路径，例如 posts/post_1.zh-cn.md，此时会在 content/posts 路径下创建 post_1.zh-cn.md。 hugo server -D 该命令会启动服务器，并使你能在本地预览 Hugo 博客，预览地址默认为 localhost:1313。 hugo 该命令会在 public 文件夹下生成可部署的静态网页文件。 ","date":"2022-03-08","objectID":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/:2:1","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Course"],"content":"引入 Hugo 主题 假设你已经搭建了一个 Hugo 博客工程文件，现在我们可以引入 Hugo 主题来简化后续网站的风格搭建工作（当然你是大佬或者你想自己配置风格除外）。Hugo 主题可以在这个网站找到，你可以在其中挑选一个你喜欢的，我这里使用的是 FixIt，同时也推荐几个个人认为比较适合的主题：Clarity、Even、Meme、Octopress。 当你挑选好主题后，你可以直接将其克隆到你的 themes 文件下，或者初始化你的项目为 git 仓库，并且把主题仓库作为你的网站目录的子模块。 git init git submodule add https://github.com/Lruihao/FixIt.git themes/FixIt 由于后续我们希望使用 Github Action 来便捷部署 Hugo 博客，因此这里需要使用第二种方法。下载完主题后，你应当根据主题中的 ReadMe 或相关文档配置你的 config.toml 文件，另外为了后续部署，你应当将你的主题作为一个子模块挂载到你的博客并修改 baseURL，具体来说是应当在你的 config.toml 文件中添加修改： baseURL = \"xxx\" # 后续你的博客的地址 [module] [[module.imports]] # xxx 为 themes 文件下你的主题文件夹的名称 path = 'xxx' 另外需要注意的是，如果该行配置应当写在 theme=xxx 配置前，同时如果该行写在 defaultContentLanguage=xxx 前，则会使得defaultContentLanguage=xxx配置失效而导致一些莫名其妙的错误。 ","date":"2022-03-08","objectID":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/:2:2","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Course"],"content":"GitHub 配置 首先说说我们自动化部署的最终目的，即希望在本地预览无误后，直接推送工程文件到 Github 的某个工程仓库后，我们的主页仓库（即https://github.com/xxx/xxx.github.io ）就会自动更新，使得访问 xxx.github.io 或者你配置的域名时得到的就是更新的内容，而不用每次手动将工程文件下的public 文件夹 push 到我们的主页仓库。 为此我们需要使用 Github Actions 来完成这一过程，它可以监听围绕代码仓库管理的各种事件，比如 push 和 pull_request 事件，触发提前计划好的一系列步骤，即工作流。这些步骤用 YAML 文档记录。触发工作流包括了构建和测试。这些工作流可以在 GitHub 的服务器上执行，开发者也可以在自己的服务器响应从 GitHub 触发的事件来执行工作流。 ","date":"2022-03-08","objectID":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/:3:0","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Course"],"content":"创建并配置 GitHub 工程仓库 首先创建一个私有的 Github 仓库用于存储工程文件，而后在该仓库页 setting -\u003e Secrets -\u003e Actions 下通过 new repository secret 创建一个新的动作密钥，并且注意一定要勾选 Allow write access。密钥可以采用 ssh-keygen 命令生成密钥对，并将私钥填入，下面是参考密钥对生成代码。另外并假设这里你创建的动作密钥名称为 ACTIONS_DEPLOY_KEY。 ssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\" # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key) ","date":"2022-03-08","objectID":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/:3:1","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Course"],"content":"创建并配置 GitHub 主页仓库 而后创建你的主页仓库，它应当是公开的，同时其仓库名应当是 xxx.github.io，其中 xxx 为你的 Github 用户名。在该仓库页 setting -\u003e Pages 你可以看到你的 Github Page 地址，同时下面的 Custom Domain 可以用以自定义地址的域名（你需要先购买一个并配好相关设置）。然后在 Deploy keys -\u003e Add deploy key 中添加对应的部署密钥，其值为先前 ssh-keygen 生成的公钥。 ","date":"2022-03-08","objectID":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/:3:2","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Course"],"content":"创建并配置 GitHub Actions 在工程仓库对应的本地文件夹下，创建.github/workflows/github-pages.yml 文件，文件名你可以自定义，然后修改文件内容如下： # This is a basic workflow to help you get started with Actionsname:Github Pages# Controls when the workflow will runon:# Triggers the workflow on push or pull request events but only for the main branchpush:branches:[master ]pull_request:branches:# Allows you to run this workflow manually from the Actions tabworkflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:# This workflow contains a single job called \"build\"build:# The type of runner that the job will run onruns-on:ubuntu-latest# Steps represent a sequence of tasks that will be executed as part of the jobsteps:# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it- uses:actions/checkout@v2# 后续版本可能有更新，请选择合适的版本with:submodules:true# 根据你是否添加子模块而定fetch-depth:0- name:Setup Hugouses:peaceiris/actions-hugo@v2# 后续版本可能有更新，请选择合适的版本with:hugo-version:'0.93.2'# 根据你的 Hugo 版本而定extended:true# 根据你的 Hugo 版本而定- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3# 后续版本可能有更新，请选择合适的版本with:DEPLOY_KEY:${{ secrets.ACTIONS_DEPLOY_KEY }}# 这里对应上面创建的动作密钥名称EXTERNAL_REPOSITORY:xxx/xxx.github.io# 部署的主页仓库PUBLISH_BRANCH:masterPUBLISH_DIR:./public 而后通过 git 或其他工具将该工程项目 push 到 对应GitHub 仓库中，等待一小段时间再次访问 xxx.github.io，即会发现对应的网页已经自动发生修改。如果发生错误，你会收到一封通知邮件，你可以通过 Actions 进入对应的 workflow 查找错误原因，并自行 debug 或通过 谷歌 和 百度 搜索相关经验。后续我们要对博客进行修改，也只需要修改工程文件然后 push 即可。 ","date":"2022-03-08","objectID":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/:3:3","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/%E5%88%A9%E7%94%A8-github-actions-%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%8C%96-hugo-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/"}]