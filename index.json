[{"categories":["DataStructure"],"content":"今天学了二分图，暂且先记录下。 二分图的定义 二分图，又称二部图，英文名叫 Bipartite graph。对于某个二分图 G = {V, E}，存在一种关于分割方案，G1 = {V1, E1}, G2 = {V2, E2}，即 V1 + V2 = V 且 E1 + E2 = E，使得 ${\\forall} e_{uv} \\in E1 \\ or \\ E2, \\text{u,v不同时属于V1或V2}$。 下面是一张示意图： 二分图的性质 如果两个集合中的点分别染成黑色和白色，可以发现二分图中的每一条边都一定是连接一个黑色点和一个白色点。 二分图不存在长度为奇数的环（因为每一条边都是从一个集合走到另一个集合，只有走偶数次才可能回到同一个集合） 二分图的判定 从上面的性质可以看到，我们只需要判定是否可以将图中的顶点分成两个满足条件的集合出来。那么采用染色的方法，遍历尝试是否能将整张图染成两种颜色。其步骤如下： 遍历所有节点，首先将所有孤立节点标记为颜色A 将所有非独立节点加入某集合，而后随机选取某个节点T，赋予颜色A并加入队列 若队列为空，则先从2中集合弹出某随机节点T，赋予颜色A并加入队列；反之直接从队列中弹出某随机节点S 对于所有与节点S相连的节点T 若尚未遍历节点T，则赋予其与S相反的颜色 反之若T的颜色与S颜色相同，说明同一颜色的集合内部存在连接，因而存在奇数环，遍历结束 最后将节点T从2中的集合中删除 对应的 java 代码如下： public class Solution{ private final static Random rand = new Random(); // 随机初始化一个矩阵表示的图 public static boolean[][] initRandomGraph(int vNum){ boolean[][] graph = new boolean[vNum][vNum]; for(int i = 0; i \u003c vNum; ++i){ for(int j = 0; j \u003c vNum; ++j){ if(rand.nextInt() \u003e 0){ graph[i][j] = true; } } } return graph; } public static boolean isBGraph(boolean[][] graph, int vNum){ // 颜色记录 int[] colors = new int[vNum]; Arrays.fill(colors, -1); // 记录未访问的节点 Set\u003cInteger\u003e unseen = new HashSet\u003c\u003e(); for(int i = 0; i \u003c vNum; ++i){ unseen.add(i); } // 染色所有孤立节点 int start = 0; while(start \u003c vNum \u0026\u0026 isAlone(graph, start, vNum)){ unseen.remove(start); colors[start++] = 1; } // 所有点都是孤立节点也是二分图 if(start == vNum){ return true; } Deque\u003cInteger\u003e dq = new ArrayDeque\u003c\u003e(); colors[start] = 1; dq.offer(start); while(unseen.size() \u003e 0 || dq.size() \u003e 0){ // 存在多个孤立的子图的图的情况 if(dq.size() == 0){ for(int num : unseen){ start = num; break; } unseen.remove(start); colors[start] = 1; dq.offer(start); }else{ // 验证单个子图是否存在奇环 start = dq.poll(); // 自环 if(graph[start][start]){ return false; } for(int i = 0; i \u003c vNum; ++i){ if(graph[start][i]){ // 对于未访问的节点，标记其为另一个颜色(集合) if(colors[i] == -1){ colors[i] = 1 - colors[start]; dq.offer(i); unseen.remove(i); } // 同颜色(集合)的节点间存在边，证明存在奇环 if(colors[start] == colors[i]){ return false; } } } } } return true; } // 判断是否为孤立节点 public static boolean isAlone(boolean[][] graph, int loc, int vNum){ for(int i = 0; i \u003c vNum; ++i){ if(graph[loc][i]){ return false; } } return true; } } ","date":"2022-08-16","objectID":"/bipartite-graph/:0:0","tags":["DataStructure"],"title":"【图论系列】二分树","uri":"/bipartite-graph/"},{"categories":["JapaneseTranslation"],"content":"在失去了所有的世界中，我与你相遇——。 于是乎，我与你相遇—— 你与我之歌 世界终焉 故事：桥本纺 插画：高野音彦 略显昏暗的便利店里一片寂静。 独自一人的我像洄游鱼搬在店内来回走动。我不断将炊饭、油渍沙丁鱼罐头和塑料瓶装的矿泉水等装入购物篮中。 而在杂志摊前，我终于停下了脚步。 现在明明是冬季，那里放置的杂志上却排满了“夏”的字眼。杂志的封面上是微笑着的泳装模特。我也学着模特微笑了起来。但窗户上映射出的我的脸上却没有一丝快乐。嘛，即便是模特的笑脸，仔细观察的话也会发现她脸上没有丝毫快乐。 拿上所有的必需品后，我离开了便利店。 当然，钱是没付的。 因为这个世界上已经没有收银员了。 我边听着发电机噗噗作响，边吃着饭。 我热了热炊饭，打开了油渍沙丁鱼罐头，喝了口矿泉水。 我的房子位于西新宿尽头。它只是个刚好六畳的单间。透过小小的窗户，街上的高楼大厦和下面平坦而宽广的城镇都尽收眼底。不过现在都淹没于一丝惨淡的月光中。不仅亮着灯的房间一间都没有，而且高楼大厦就像是黑色的墓碑。 但它们或许确实就是墓碑。 因为人类已经要灭绝了。 仅是名大学生的我不太清楚到底发生了什么。 一开始确实有看到中南美各国发生了奇怪的发烧的报道。而后没过几天报道就变成了「美国的奇怪发烧症愈发凶猛」。紧接着遭罪的则是欧洲。然后是非洲、亚洲……整个世界在短时间内就陷入了疫病之中。由于发生地过于仓促，感觉似乎谁都不清楚到底发生了什么。 大部分的人类都死了。 不过半年，人类就已经要灭绝了。 我也不清楚为什么我还活着。 或许是我的运气好，又或者是我对疫病有什么抗性。 嘭 嘭 当球撞到墙壁时，就会发出这样的声音。我偶尔也会打网球。当然由于没有接球的人，我也只能对着墙壁打。 嘭 嘭 网球在我和墙壁之间不断来回。 不久后，疲倦的我坐倒了下来。 天空很蓝。 鸟叫声在四处回荡。 空气比以往更清新。 即便人类灭绝了，世界却没有任何变化。 尽管有人会觉得这很奇怪，但也有人觉得这理所应当。人类，不过是极为渺小的存在罢了。 我把眼睛闭上，缓缓地调整着呼吸。 不久后，不知何处传来了猫叫声。喵、喵地叫着，十分动听。好奇怪啊，我这么想着。猫只会在请求喂饭的时候才会发出这种声音。猫与猫之间用这种声音交流，肯定是不可能的。猫叫声在不断向我靠近。 我急忙站起身来。 我惊了。 有一个女人独自走在公园的路上。而她身后跟着很多猫猫。有黑猫、白猫、茶色的猫、双色猫、棕斑猫和银斑猫等。 数量上则过百了。 「你好」 我反射性地打了个招呼。上次见到活人已经是五个月前的事了。因为我认为已经只有我还活着，而其他人都已经死了。还是说…….那只不过是幻觉。只不过是因为我受不住寂寞而机缘巧合般创造的幻觉吧。 她注意到了我。 「该怎么应对这些猫猫啊」 她一脸困惑地这么说着。 「想给它们投喂食物，结果却聚集了这么多只过来」 发生了好多事。 真的发生了好多事。 人类在其终焉又暴露出了他所有的丑态。 所以要保持理智是很困难的。即便是我，一直独自生活久了也会有要疯掉了的感觉。又或许，我已经疯掉了。 她那天晚上对我这么说道。 「我啊，是调查体」 「调查体是指？」 「因为这颗星球上的智慧生命体即将灭绝，所以我要在其完全灭绝前记录它们到底是怎样的生命体」 「所以…你是宇宙人？」 「稍微有点差别。我并不是宇宙人，我只是调查体而已。一种类似生物机械的东西」 我谨慎地点了点头。 「所以你化为人身只是为了不让我害怕？」 「是的。你很聪明嘛」 因为她声称要“调查”我，所以便和我一起生活。 当我问她的名字时、 「名字、那是什么」 她则这么回答道。 「嗯，名字是用来标识身份用的称呼」 「啊，我明白了。但我没有那种东西。那就由你来决定吧」 「那就取名——雪」 因为是冬天，所以取名雪。 十分单纯的想法。 尽管我并没有相信她说的话，雪确实是个奇妙的人。 她什么都不知道。 由于加热炊饭过久，反而将包装弄碎了。 罐头直接上嘴啃。 把发电机认为是小型的吵闹的活物。 当雪睡着后，我偷偷看了眼她的睡颜。 呼——呼——，她平稳地呼吸着。无论怎么看她都只是个普通的女子。完全无法相信她是台机械。啊，但是，她说她是生物机械来着。真亏她能想出那种借口。 但在她的肩膀旁，有一颗奇怪的痣。 看着似乎是什么记号。 宇宙人？ 调查体？ 不会是真的吧。 我教会了她打网球。 嘭 嘭 网球在我与她之间不断来回。 嘭 嘭 她渐渐地熟悉了网球。 嘭 嘭 网球在我与她之间不断来回。 打了很长时间后，我们走向了公园的一个角落。 那里有一棵标志性的巨大橡树。 在它的树根处、埋葬着佳奈。 「这是什么」 她看到了一根突兀的棒子后这么问道。 我这么回答道。 「这是和我稍微有些交情的朋友。因为她死了，便埋在了这里」 「人死后，你们就会把他埋到土里吗？」 「是的」 「你会偶尔这样过来看她是吗？」 「嗯」 我把塑料瓶装的矿泉水倒过来。喝了一半的矿泉水咕噜咕噜地滴落在橡树的根部，而后被其所吸收。 「实际上我想给她带桃肉罐头」 「桃肉罐头？」 「因为吃下它似乎就会元气起来」 我和佳柰相遇，也是在这个公园。 她倒在地上。 脸上和身上都是泥巴，衣服破破烂烂的，鞋子也没有穿。将她抱起来时，她的身体就像火炉般滚烫滚烫。她早就发病了。 于是我便将她带回我的房间照顾。 高烧三天后，她睁开了眼睛。 「不、不要……」 她一看到我，就用非常胆怯的声音这么说道。 人类在其终焉又暴露出了他所有的丑态･････。 佳柰很难相信我。 她一直用怀疑的眼神看着我，每当我来到身旁时也总是身体发颤。晚上睡觉的时候也是将自己锁在单元浴室里。 在相遇的第七天，她终于露出了笑脸。 那是我询问她想吃什么的时候、 「桃肉罐头」 她这么回答道，于是我便去附近街道的超市寻找罐头。常去的便利店里并没有罐头。 我找了两个小时后我终于找到了一个并交给了佳柰。 「谢谢」 佳柰在接过罐头的同时，第一次笑了。 「谢谢」 那是个要哭出来的笑容。 而那却是最后的笑了。 翌日早上，她便停止了呼吸。 夜晚——。 想起了佳柰的事，雪便前来问我。 「和史，你好奇怪啊」 「诶，哪里奇怪？」 「你从刚才开始就一直没说话」 「因为我在思考东西」 「人类在思考时就不会说话吗？」 「视思考的东西而定」 我盯着雪的脸。 内心深处，似乎有什么地方被触动。 世界笼罩在月华下。 像是月光的大海。 我已经不想再失去任何东西。 世界迎来了它的终焉。 我的内心在不断挣扎。 我已经不想再得到任何东西。 不曾拥有，便不会失去任何东西。 即便人类消失了，太阳也照常升起落下，风也照常带走热量。我的心中似乎发生了什么变化。但我并不想承认它。因为我不想知道它。 「和史，你怎么了」 雪这么问道。 「最近你完全不说话啊。我们马上去哪玩吧」 我边穿着外套，边这么回答道。 「我很忙的。我要稍微出去一趟」 「那我也去」 「你不来也可以。因为我很急」 我慌乱地跑出房间。雪的脸和充满不安的瞳孔快速地涌上心头。不曾拥有，便不会失去任何东西——。 我到底走到哪了。 冷风吹得耳朵发疼。脚尖也变得麻木起来。但我还是不停地走着。因为没有目的地，所以可以任意向前走。 对啊，就这么走到南极也可以。 离开这座城市吧。 再回归独居的生活吧。独自醒来、吃饭、入睡。谁也不能动摇我的内心。不能摧毁我的内心。只要在失去前丢弃就好了。如此简单的事。尽管雪会暂时感到寂寞，但不久后也会明白吧。 我带着一半的理智这么想着。 不久后我便看到了新宿车站。 我不带任何思考，直接越过闸口，继续向前。 「嘿，你好！」 当我到达十二号线站台时，从高处传来了这样的声音。 站台上有一个大叔独自站着。灰色的西服配着白色的衬衫，胸前则是蓝色的领带。 还有幸存者啊……。 大叔对着震惊的我这么说道。 「电车还没来啊」 「嗯….」 「糟了啊。我要让我的客户等我了」 哈哈哈，大叔这样笑道。 「但电车迟到也是没办法的事。还是好好休息吧」 仔细看的话，大叔的西服满是皱折。 衬衫的领口处沾满了油污。 而他的眼中则充斥着疯狂。 电车已经不会来了——。 「电车能早点来就好了！」 我边这么喊着边飞奔上了站台的楼梯。 以每步二级台阶的速度爬了上去。 回到房间后，却没发现雪的身影。 「雪？」 我的声音在狭小的房间内空洞地回响着。 等待的第一个小时。 等待的第二个小时。 等待的第三个小时。 雪却没有回来。 太阳开始完全下山，将整个世界染成赤红。 沐浴在这种光线中的我搜寻着雪。常去的便利店。不在。斜坡上方去过的某图书馆。不在。网球场。不在。 我突然想起什么，朝着佳柰沉眠的地方走去。 橡树的树根旁放着一个逗猫棒。 「她来过这啊……」 要在墓前供奉你重要的东西，前些日子我曾这么告诉过她。 「我错了，雪！」 当我回过神来，才发现自己在边跑边这么呢喃道。 「即便将逗猫棒供奉给佳柰她也不会高兴的！」 我找遍了所有地方。一片漆黑的公园、大厦间的小道、满是涂鸦的高速公路的路肩，我喘着粗气不断地寻找着。喊着雪的名字。我的声音空洞地回荡在空洞的城市里。 尽管因为恐怖和焦虑而近乎疯狂，我还是一直追问着自己。 为什么我要这么拼命？对方不就是个内心疯狂的女子而已吗？不就是从何处过来，又去到何处而已吗？看啊，这不是正如你所愿，又回到了独居的生活了。但是，为什么你在嘶吼？在奔跑？你究竟在追求着什么？ 雪！你在哪里！？ 突然，从路肩处跑出来什么东西。 那是只茶色的猫。 猫猫们开始不断出现。 有黑猫、白猫、茶色的猫、双色猫、棕斑猫和银斑猫等——。 我朝着路肩内部望去。 在那里站着的是雪。 她带着几百只猫猫，朝这里走来。 我注意到雪笑了。 「我想着给猫猫喂食，结果就来着这么多只」 「你去…去哪了？」 我边喘着粗气，边这么问道。 她递过来一个圆圆的东西。 「吃下它的话，和史应该","date":"2022-07-17","objectID":"/kimi-to-boku-no-uta/:0:0","tags":["Japanese"],"title":"你与我之歌 世界终焉","uri":"/kimi-to-boku-no-uta/"},{"categories":["JapaneseTranslation"],"content":"八丈岛有人死了——如寄到警视厅的奇怪文书里所描述那般，在岛上的山脊上发现了被刺杀而死的尸体。像是在等待着被派往现场调查的搜查一科的岛丸弘美和弗雷德里克・纽曼两个刑警似的，第二起杀人事件再次发生。受害者是度假社团的新社长。但是杀人事件并未就此终止。发端自10年前南太平洋的乐园大溪地之海中飘浮的「手腕」，不断发展的怨念的惨剧在疯狂地裹挟新的牺牲者。在财津大三郎警部的指挥下，岛丸弘美是否能揪出眼前的真凶！","date":"2022-06-11","objectID":"/south-pacific-killing-case-1/","tags":["Japanese","SouthPacificKillingCase","YoshimuraTatsuya"],"title":"【南太平洋杀人事件 吉村达也】（1）作品说明+序章","uri":"/south-pacific-killing-case-1/"},{"categories":["JapaneseTranslation"],"content":"写在前面 本文为作者个人汉化作品，因个人水平有限，如有遗漏错误欢迎私信指出。 未经作者本人允许，请不要在任何平台转载，谢谢！ 附：封面图为文中提到的大溪地・波拉波拉岛，真的非常美丽！ 作品目录 序章——1977年 大溪地 第一章——1977年 八丈岛 诱惑的夜晚 美味的面包 血色玛丽 错认的乐观者 终局 第二章——1987年 大溪地 愉快的谈话 巴里海岛 想忘记那个人 两人的独白 终章 作品说明 作品说明 本作品是作者的早期作品。为了理解故事背景，推荐从作品说明开始阅读本书。 登场人物 人物身份 大谷 浩吉 WRC(世界度假协会)会长 大谷 诚 浩吉的儿子、WRC社长 大谷 芽里 诚的妻子、副岛努的姐姐 副岛 努 WRC常务 副岛 悦 芽里、努的祖母 伊藤 次郎 「艺能周刊」的主编 泽田 明梨 「艺能周刊」的编辑记者 久米 WRC宣传部部长 山崎 「艺能周刊」的后勤部部长 田村 麻美 「艺能周刊」的社长秘书 小田 小混混 健太 小混混 财津 大三郎 警视厅搜查一科的警部 弗雷德里克・纽曼 警视厅搜查一科的刑警 岛丸 弘美 警视厅搜查一科的刑警 源 朝三 八丈警局的警部 序章——1977年 大溪地 「哇、好美的大海」 泽田明梨无意识地大声喊了出来。 眼前的大海从祖母绿蔓延至蓝绿，又由蓝绿蔓延至靛蓝，浓淡交织，甚是美丽。 南太平洋的天空和大海，在远方交织在了一起。 (如果伊藤没有躺在屋子里睡觉，而是和我一起过来就好了） 明梨的脑海里忽的就浮现出在岛上的小木屋中懒散度日的主编伊藤次郎的身影。 （嘛算了。如果他跟着一起就没法穿成这样了） 明梨直勾勾地盯着自己随着海水沉浮而隐约浮现出的胸部。 只有那里仍旧一片雪白未被晒黑，而这也更突显了F罩杯之大。 她开着一艘粉色的双体型快艇离开海岸，直到海水浸没膝盖的地方才停下。 将为了不被珊瑚割到脚的塑胶凉鞋扔到船底后，她身上剩下的就只有一片大红的比基尼和头上戴着的水下眼镜。 在水浅的地方，大海呈现出接近白色的浅绿。海水也十分透明。她将头埋入海中，便看到了热带鱼群们因为游艇受惊而逃的五彩的舞蹈。 波峰形成的光斑反射在海底，随着海浪的起伏不断往复运动。 被珊瑚礁包围的大海，终归还是平稳的。 明梨回头看了眼抛在身后的小岛。 波拉波拉岛——与赤道的距离相比大溪地少了250千米，同时也是世界上被礁湖包围的最美丽的岛屿。 如果允许“大溪地最后的乐园”这一形容的话，那么除了用于波拉波拉岛没有其他东西更合适。它也是电影「迪克与鲨鱼」中登场的岛屿。 这座岛屿尚未被近代文明污染。阳光、风、天空和海洋中演奏着无法听闻却能感受到的乐园的和谐感。 明梨为了登上珊瑚礁的浅滩，慎重地驾驶着游艇。凉爽的风平稳地向着作为新手的她也能找到道路的方向吹着。 身后能看到她们在波拉波拉上投宿的旅馆・诺艾诺艾的水上小木屋。 前方则是一个小型无人岛Moto Tapu。那里就是她的目的地。 充分环游后，明梨把游艇停在了无人岛的白色海岸上。 昨晚的野餐聚会的残渣被整理到了椰子树的根脚下。堆在那里的是烧烤的残渣、为了盛放热带饮料而被掏空的菠萝和用作装饰的大溪地栀子花。 泽田明梨和伊藤次郎就职于东京的某家杂志社。由于某个南太平洋指南的杂志书籍企划，两人便来到大溪地、斐济、萨摩亚等岛屿取材，而她们第一个目的地便是大溪地。 但杂志社内满是关于单单两人前去取材过于“危险”的谈论。“危险”是指让二十九岁的男人和刚满二十岁的女孩两人单独前往海外长期取材是否合适，是否会引发矛盾。 特别是泽田明梨不仅脸蛋可爱，还有着不似日本人般丰满的身材，而这便更让人担心了。 明梨虽然听着这样的言论，心里却想着即便发生矛盾了，如果对象是伊藤的话也没事。 伊藤总是顶着一副晒黑的健壮身材，满脸智慧。他又聪明又有良好的人际关系。尽管太受女性欢迎是一个小缺点，但受欢迎的男性肯定远比被无视的男性要好几百倍。 而实际上，对于泽田明梨，这次前往南太平洋的岛屿的取材，就是将伊藤的全部抽丝剥茧（如果用古老的说法的话）的机会。 但话说回来，讽刺般的偶然事件却发生了。 在波拉波拉岛，伊藤遇到了他以前的女友。这简直就是命运的捉弄。对方的名字还和自己一样是「メリ」。只有汉字不同。 副岛芽里——这就是那个女人的名字。 而将这座Moto Tapo岛堆满野餐残骸的，便是包括她在内的日本一行人和当地的权贵们。 日本一行人包括称作世界旅游协会的旅游景点建筑公司的职员和公司的家族，而当地人则是前来迎接他们的相关人员。 简而言之，似乎是要由日本注资在波拉波拉岛建立旅游酒店和娱乐设施。而伊藤次郎的前女友，则和那个公司的社长的儿子订有婚约。 伊藤本就躲在屋子里不在闪耀的阳光下活动，听闻前女友的婚约的事情后便更加自暴自弃地喝起了闷酒。 （那种人还是忘掉比较好。她给人的第一印象不是非常神经质且阴暗么） 明梨面对着几乎和自己差不多大，而且名字读法还相同的女性燃起了熊熊的嫉妒心。 （嘛算了。今天难得放假、还是忘掉那些尽情游泳吧） 明梨一直走到Moto Tapo岛的另一侧尽头，然后跳入祖母绿色的海中向外游去。 尽管游到了离岸很远的地方，泻湖中央仍旧很平静。 有时明梨也会大致浮在海面上，而后尽情享受南太平洋的阳光浴。温热的海水在耳边发出透明的声音。 我到底游了多远了。想着差不多该回岸边而切回蛙泳的姿势时，明梨看到令她浑身僵硬的场景。 她和无人岛大约相距两百米。而这之间发生了异变。鲨鱼的鱼鳍在水面上来回画着圈圈。鲨鱼一共有两条。 尽管常说鲨鱼无法侵入泻湖，但由于包围着Moto Tapo岛外侧的环礁有着缝隙，因此有时也会有鲨鱼从外海游进来。 明梨虽然看见那恐怖的鱼鳍的运动，但她毅然戴上水下眼镜，朝着那边游了过去。 她虽然不熟悉游艇，但对深潜却很有自信。在南方海域深潜的次数甚至超过了50次。因为深潜是父亲的兴趣，所以从小开始她就很擅长。 而她至今为止曾多次遇到过鲨鱼。只要保持一定距离，不去无谓地刺激它们，就不会单方面地遭受攻击。 但是，在她前方持续画圆的鲨鱼却异常地兴奋。不知何时间，鱼鳍的数量增加到了五个。 她将双手合一，朝水下游去。 周围的天蓝色小鱼群，分化为二向远方游走。 正面靠近的黄色的热带鱼们看到眼前极速的U形鱼群，便朝着来的方向逃去。 明梨透过水下眼镜试着凝视远方。 远处的大白鲨群似乎在绕着水中的什么东西疯狂地游动着。那东西有着蓝灰色的轮廓。 她谨慎地靠了过去。暂时浮出水面确定了和鲨鱼的正确距离后，她便再次屏气潜入水中。 鲨鱼总共有7只。意料外的数量使得她很紧张。 水下3米的地方，刚好有一个单人能进去的凹陷的珊瑚礁。明梨便藏身与此，暂时观察着前方的鲨鱼的行为。 有一只鲨鱼在吃着什么。 肉片在水中散开。 在前方用凶暴的牙齿撕扯的大白鲨，顶着灰色的眼睛盯着明梨。尽管那可能只是错觉，明梨却不自觉地朝着珊瑚礁的掩体里将自己完全藏了起来。 她的乳房由于和珊瑚摩擦而变得赤红。在试图躲藏的瞬间，右腕也被珊瑚擦伤了。明梨便慌张地开始检查有没有出血。如果被鲨鱼闻到血腥味就完了。 幸运的是，伤口没有出血。 那只鲨鱼脱离鱼群，像是胜者般朝着明梨的方向游了过来。在白天透明度极高的海中，极限距离下注视鲨鱼的魄力极为惊人。 而在屏息观看的明梨的仅仅5米的地方，便是悠闲地堵住前路的鲨鱼。 鲨鱼经过身旁的瞬间，当她看到鲨鱼的牙齿上挂着的夏威夷衫时，明梨因为恐怖睁大了双眼。 （那只鲨鱼在吃人！） 心脏跳动的声音在耳边不断回响。 （必须回到波拉波拉岛将这件事告诉大家） 屏息的极限到了。 剩余的六只大白鲨还在同一个地方放肆地吃着饵食。在猎食猎物时，鲨鱼为了保护眼球会露出白眼。而那则让人感觉非常恐怖。 总之即便要绕远路回岛那也是安全的。一直待在附近闲逛的话，就会成为尝到血腥味的鲨鱼的第二目标。 为了浮上水面，她无意识间举起了双手。而手上则接触到了什么。她下意识往上看去。 一瞬间，她还以为是别的深潜者在朝她伸手。 而那碰到的东西，却是带着银色指环体毛茂盛的男性手臂。 但是手腕以上却不见了。 那不是人类，只是只手腕而已。 明梨睁大眼睛试图扔掉它。 但是它在水中转了一圈，又朝她的方向飘了过来。 （不要——） 明梨惊叫道。 苍白的男性的手腕像生物般在她周围活动着，偶然间某个手指碰到了她的乳头。 （救救我） 明梨误吞下一口海水，错乱地浮上水面。 吐出海水，深吸一口气后，明梨大声呼救到。 「救救我——」 但能听到她的呼救的，只有南太平洋上空高处闪耀的白色太阳而已。 「救救我——」 呼救数次后的明梨的前方，是依旧不断画圈的黑色鱼鳍。 下集精彩继续——————\u003e ","date":"2022-06-11","objectID":"/south-pacific-killing-case-1/:0:0","tags":["Japanese","SouthPacificKillingCase","YoshimuraTatsuya"],"title":"【南太平洋杀人事件 吉村达也】（1）作品说明+序章","uri":"/south-pacific-killing-case-1/"},{"categories":["JapaneseTranslation"],"content":"八丈岛有人死了——如寄到警视厅的奇怪文书里所描述那般，在岛上的山脊上发现了被刺杀而死的尸体。像是在等待着被派往现场调查的搜查一科的岛丸弘美和弗雷德里克・纽曼两个刑警似的，第二起杀人事件再次发生。受害者是度假社团的新社长。但是杀人事件并未就此终止。发端自10年前南太平洋的乐园大溪地之海中飘浮的「手腕」，不断发展的怨念的惨剧在疯狂地裹挟新的牺牲者。在财津大三郎警部的指挥下，岛丸弘美是否能揪出眼前的真凶！","date":"2022-06-11","objectID":"/south-pacific-killing-case-2/","tags":["Japanese","SouthPacificKillingCase","YoshimuraTatsuya"],"title":"【南太平洋杀人事件 吉村达也】（2）第一章 八丈岛 诱惑的夜晚 1","uri":"/south-pacific-killing-case-2/"},{"categories":["JapaneseTranslation"],"content":"写在前面 本文为作者个人汉化作品，因个人水平有限，如有遗漏错误欢迎私信指出。 未经作者本人允许，请不要在任何平台转载，谢谢！ 附：封面图为文中提到的社会群岛，真的非常美丽！ 作品目录 序章——1977年 大溪地 第一章——1977年 八丈岛 诱惑的夜晚 美味的面包 血色玛丽 错认的乐观者 终局 第二章——1987年 大溪地 愉快的谈话 巴里海岛 想忘记那个人 两人的独白 终章 作品说明 第一章——1977年 八丈岛 ","date":"2022-06-11","objectID":"/south-pacific-killing-case-2/:0:0","tags":["Japanese","SouthPacificKillingCase","YoshimuraTatsuya"],"title":"【南太平洋杀人事件 吉村达也】（2）第一章 八丈岛 诱惑的夜晚 1","uri":"/south-pacific-killing-case-2/"},{"categories":["JapaneseTranslation"],"content":"诱惑的夜晚 ","date":"2022-06-11","objectID":"/south-pacific-killing-case-2/:1:0","tags":["Japanese","SouthPacificKillingCase","YoshimuraTatsuya"],"title":"【南太平洋杀人事件 吉村达也】（2）第一章 八丈岛 诱惑的夜晚 1","uri":"/south-pacific-killing-case-2/"},{"categories":["JapaneseTranslation"],"content":"1 「咳，在这么盛大的聚会上，作为本人的父亲带头干杯本就很奇怪了，而且还是以世界度假协会董事长而非父亲的身份发言，这当然 是被员工们怂恿的」 一阵大笑声传遍室外的聚会。尽管是个微热的夏夜，星星的数量却并不算多。 「总之让我们为犬子——抱歉、重来。让我们为大谷诚就任新社长干杯」 话音落下，全场目光都聚集到中央舞台侧面站着的修长但似乎有些神经质的三十多岁的男子身上。 被称作诚的新社长边摆弄着胸前装饰着的大束玫瑰，边不断地眨着眼。 「上上个月，正好是两个月前的 5 月 11 日，这家世界度假协会八丈岛分会正式开业。 而领头指挥本协会开展工作的，便是当时的副社长大谷诚。而后， 由于先前在股东大会上决定罢免前社长五十岚并任用诚为新社长，因此股东会的会长——哦，会长就是我，提议在这个充满他的回忆的八丈岛上举办本次就职纪念协会」 场下又是一片笑声响起。 但其中一半则只是随波逐流而已。 「诸位从东京远道而来——而这座八丈岛也归属东京都，尽管这么说会招来众怒——嘛、感谢你们特意包机从羽田赶来本地。 啊，还请诸位谅解本人冗长的致辞。香槟酒就放在桌子上。希望大家尽情享受本次聚会」 尽管口吻很诙谐，但实际上因为致辞会很长，所以大家都被命令要好好听着。 现场十分热闹，服务员们不断往桌上添置着香槟酒。 WRC（世界度假协会）八丈岛分会的中央花园处的聚会现场被特制的灯光照的恍若白昼，而桌子上则摆满了装饰有八重桑或是扶桑花的热带饮料。 会场的周围是围成一圈的亚热带树，而其外侧则是大海——太平洋在轰鸣。 聚会开始后风力便不断增强，波浪也愈发汹涌。 当疾风吹来时，女性们会按住头发，捂住裙子。而服务员们则四处奔走捡拾被吹飞的纸餐巾。 这是个夜风很强的夜晚。但无论怎样激烈也不会让人感到寒冷。 WRC 股东代表会长的大谷浩吉双手拿着一杯香槟酒，眺望着坐着的二百五十人——并非开玩笑所言的包机而是乘坐定期航班而来的客人们，并依次与其打着招呼。 「那么，如大家知道的那样，世界度假协会，正如其名，作为日资度假协会，在海外独特地开展活动。至今为此开设的海外 WRC 分部总数高达 27 家，其中距离较近的有关岛、塞班岛、罗塔岛和韩国济州岛分部，较远的则有位于地球正背面的巴西和里约热内卢海岸的伊鲁格兰德岛。 而本次我们则着手建立了第 28 家海外 WRC 分部。那便是新社长大谷诚的第一份成果—世界度假协会波拉波拉岛分会。 提起波拉波拉岛，想必有人会好奇它究竟位于何处。大致来说， 它位于被称作社会群岛的地方，与夏威夷岛关于赤道对称。从澳大利 亚向东画线，而后从夏威夷岛往右下画线，位于南太平洋处的二者的 交叉点便是社会群岛。其中因为保罗高更而闻名便是大溪地，再从那里乘坐飞机大约 1 小时候便是波拉波拉岛。 而大溪地，想必大家都已经有所听闻。大溪地本岛稍微前面的莫雷阿岛，便在著名的音乐剧「南太平洋」中作为巴黎海岛登场，而波 拉波拉岛则曾出现于「迪克与鲨鱼」和「飓风」等电影中」 大谷浩吉由于提前知道来宾中有许多电影行业人员和演员，因此便如此致辞。 尽管才五十六便满头白发而颇为出格，他却称之为银发并以此为荣。 再配上他那一头清爽的运动风短发、晒黑的脸庞和银边的眼镜， 给人的感觉更像退休的高尔夫球员而非度假协会会长。 尽管早年丧妻，但他却不曾给人一丝不幸的感觉。 「对这座波拉波拉岛开展度假设施建设，一直是包括我在内的WRC 协会全体的夙愿。实际上十年前……」大谷突然加强了语气。 「我们作为海外第三大度假协会，为了在此开设 WRC 分会，派出两个家族共 7 人前往调研，也同时作为度假。两大家族中之一，便是我们大谷家，我和社长诚父子二人。另外一个，则是现场的常务副岛努一家」 如果没有此般介绍，谁也不会认为大谷诚新社长旁边寡言的副岛努也是员工。 总之他很年轻。二十七岁的他的眼中闪烁着光芒。当夏风吹过时， 他频繁地抽动着鼻子。 「努的父亲副岛新吾，是我还是社长时的得力助手，作为专务做出了许多成果。由于和我年龄相近，无论公私我们都相谈甚欢。 因此在 WRC 波拉波拉分会建成前夕，我想着在其完成前便让副岛来兼任总负责人。 因为他很顾念家族，那么家族住在一起对他而言肯定更好，因此我便拜托他们全家来此地进行长途旅行。 副岛新吾专务的妻子道子女士，当时高二的努、与我的儿子—— 新社长诚订有婚约的女大学生芽里和专务的母亲，这便是今天也在场的另一家人」 最前列的座位——贵宾席上的其中一人便是穿着和服正坐的七十岁的副岛悦。 他边端正坐姿边仔细听着会长的致辞的目光里却暗藏着一丝尖锐。他的身旁，则是穿着一身蓝色长裙的现大谷诚夫人，副岛努的姐姐芽里。 那是个皮肤白皙且瘦弱的女性。尽管才 31 岁，也未曾有孩子，却看起来比实际年龄要老很多。明明是值得庆祝的聚会——而且还是丈夫的社长任职纪念会，芽里却几乎没露出过笑脸。 「他们七人细致地调研了波拉波拉岛，感叹其简直就是地上乐园， 作为度假地而言没有任何可抱怨的地方，并在距离波拉波拉岛不远处的无人岛和本地职员开展了共探未来的聚会。而隔天……」 在这里大谷会长停下了发言。 边窃窃私语边听着会长致辞的客人们注意到自己过大的声音，一瞬间停止了交谈。 被强风吹拂而沙沙作响的树木摇晃声，瞬间充斥了整个会场。 确认了 250 位出席者的视线都汇聚到自己身上后，大谷浩吉便开始继续致辞。 「副岛新吾因为意外去世了」 一瞬间的沉默过后，整个会场就突然沸腾了起来。“在这么值得庆祝的聚会上，会长在瞎说什么”的谈论也不断蔓延。 「因为他是那么慎重，我们只能假定他是由于建设度假地的决定而过于兴奋。那天晚上独自前往无人岛的海岸里游泳的他，隔日被发 现溺水身亡。不、准确来说是残骸大部分都未曾找到。只有很少一部 分尸体能证明他的死亡」 某处的女性因为受惊而尖叫了出来。 「对此，无论是位于现场的副岛一家，还是我和犬子诚，都是件言语难以表达的突发灾难。……当然，WRC 波拉波拉岛的建设并未就此取消。尽管十分悲痛，但我们依旧继续努力完成了计划。 半年后，因为丈夫逝去而内心折磨的道子夫人，也因为心脏衰竭而不幸去世。 但是，距离那件事发生才经过十年，当时还是 17 岁的高中生努已经成长地如此出色，还担任了本公司的常务这一大任。 他的姐姐芽里也与犬子订婚，构建了一个幸福的家庭。尽管二人尚未生子，但我也希望尽快成为爷爷，开启逗弄孙子的隐居生活」 尽管浩吉会长露出了笑容，但来宾们还沉浸在先前的震惊中。会场的氛围依旧很微妙。 但大谷浩吉不带停顿地继续着致辞。 「大谷家和副岛家，靠着年轻人而联结为一个家族。而领导着这一联系的人，也就是将大家带到此处的诚。我曾在社长就职公示前询问过他。你当上社长后，第一件事想干什么。诚则立即给出了答复。会长，请让我接手世界度假协会波拉波拉岛分部的建设工作……」 然后大谷浩吉招手示意新任社长的儿子过来，抱住了他的肩部。 「大家看啊，这个男人斗志昂扬。他跨越了十年前的悲痛，继承了副岛新吾的遗愿，和努携手共进，为了将南太平洋乐园建设成我司首屈一指的度假地而斗志昂扬。那么，让我们祝愿新任社长的大谷诚和常务辅导君前途光明，愿十年前的夙愿经由二人之手达成，干杯」 大谷会长用右手举起了香槟酒。 来宾们配合着他也各自从桌上拿起香槟酒举了起来。尽管在致辞间逸出了不少气泡，但玻璃杯内侧依旧还残留着不少碳酸。 「那么，让我们干杯！」 大谷会长高高举起了玻璃杯，全体来宾也应和着干杯。 一口喝下香槟酒后，由于再次添置香槟酒到桌上需要时间，场下便涌现出了热烈的掌声。 大谷浩吉晒黑的脸上露出了笑容——他敬礼后便从台上走了下来。而他的侧面，则是诚在边神经质般地眨眼边说着客套话。再远一点的地方则是副岛努表情僵硬地喝着香槟酒。 下集精彩继续——————\u003e ","date":"2022-06-11","objectID":"/south-pacific-killing-case-2/:1:1","tags":["Japanese","SouthPacificKillingCase","YoshimuraTatsuya"],"title":"【南太平洋杀人事件 吉村达也】（2）第一章 八丈岛 诱惑的夜晚 1","uri":"/south-pacific-killing-case-2/"},{"categories":["Japanese"],"content":"这是闲暇时想到的一点小玩意，其实就是把某个APK中的内容搬到了网页上。具体 APK 名称和拆包解析过程就不介绍了。总之你可以把它看做一个用于增加日语词汇的小游戏。希望你玩的开心！","date":"2022-05-29","objectID":"/japanese-level-test/","tags":["Japanese"],"title":"日本語語彙力診断","uri":"/japanese-level-test/"},{"categories":["Japanese"],"content":"您当前的得分为：0 请选择题目难度： １級 ２級 ３級 ４級 ５級 ６級 次の語句ともっとも関係の深い文を1～4の中から一つ選びなさい。 膠 こう 着 あの二人は仲良しだが、お互いを束縛し合っている。 両者とも自分の主張をゆずらず、交渉が先に進まない。 子どもが机に 貼 は り付けてしまったシールは、なかなかとれない。 新幹線は大雨のため徐行運転をしており、かなり遅れる予定だ。 ","date":"2022-05-29","objectID":"/japanese-level-test/:0:0","tags":["Japanese"],"title":"日本語語彙力診断","uri":"/japanese-level-test/"},{"categories":["Blender"],"content":"本文章主要记录利用 Blender 生成带光流标签数据集时遇到的各种天坑。 ","date":"2022-05-17","objectID":"/blender-optical-flow-trap/:0:0","tags":["Blender"],"title":"Blender光流踩坑记录","uri":"/blender-optical-flow-trap/"},{"categories":["Blender"],"content":"前言 因为课题需要，需要用 Blender 生成一批特定场景的带光流标签数据集用作网络训练，于是就开始了我漫长的踩坑实录，这篇文章也是因此而来。 ","date":"2022-05-17","objectID":"/blender-optical-flow-trap/:1:0","tags":["Blender"],"title":"Blender光流踩坑记录","uri":"/blender-optical-flow-trap/"},{"categories":["Blender"],"content":"正文 首先是关于 Blender 渲染方面。通过查找得知要得到光流输出需要设置渲染引擎为 Cycle，同时关闭 Motion Blur 选项，即： 但注意仅此操作，上图第一个红色选框处的 GPU Compute 会是灰色（图中已经有了额外操作），这表明最终渲染还是用 CPU（天知道之前一张 1080P 的场景我渲了 8 小时？？？）。实际上在设置中（Edit -\u003e Preference）中还要额外设置如下图所示。其中 Cycles Render Devices 下面的四个选项是让你选择用哪种方式进行渲染，而不是对应渲染方式的设置（这样一来速度啪一下变成了秒级）。 最后是关于光流输出，一开始不懂直接 Github 查找到一个插件 Vision Blender，但这插件还有版本适配问题，好多版本并不能按描述的那样得到 npy 格式的光流。然后就 Google，首先要在 Passes 里勾选 Vector 输出如下图： 然后在 Compositing 选栏下勾选 Use Nodes，Shift + A 搜索添加一个 File Output，并将 Render Layers 层的 Vector 输出与其名字（默认 image）相连（这点与 Vision Blender 代码中表现一致）。然后修改点击右侧选栏 Node 更改 File Output 的属性，最主要是改修改输出格式和文件前缀名和输出文件夹，注意对于光流最好输出 OpenExr 格式，色彩选择 RGBA，比如： 然后根据 Blender 官方文档解释（太含糊了）Vector（光流）输出代表当前帧到前一帧和下一帧的光流。但这话这么说也没讲出四维色彩 The four components consist of 2D vectors giving the motion towards the next and previous frame position in pixel space. 通道值和具体光流值的对应方式。那么继续 Google，找到一个 教程，里面指出 R, G 通道对应当前帧到下一帧的光流的 X 和 Y 方向，但 Y 方向的值需要取反，B，A 对应下一帧到当前帧的光流，同理 Y 方向需要取反。 Important information: The flow-values are saved in the R/G-channel of the output-image, where the R-channel contains the movement of each pixel in x-direction, the G-channel the y-direction. The offsets are encoded from the current to the previous frame, so the flow-information from the very first frame will not yield usable values. Also, in blender the y-axis points upwards. (The B/A-channels contain the offsets from the next to the current frame). 那么就试试开搞，然后发现如此渲染出来的光流总是没有 Alpha 通道，继续 Google，查到一个没有正确解得开放回答（找不到链接了），经验证后选取一种方法是有效的，即先拆分再合并 RGBA： 然后再经过代码验证，发现对于 B，A 通道的光流含义解释依旧有误。对于 Blender 3.1.2 版本，其 B，A 通道分别为当前帧到下一帧的 X 方向光流的相反数以及 Y 方向光流。 最后，这里给出了一个 简单的运动场景 和一段代码用于验证，有兴趣的读者可以自行尝试： # warp 部分代码摘自 ARFlow(https://github.com/lliuz/ARFlow) import torch import torch.nn as nn import inspect import numpy as np import cv2 import Imath import array import OpenEXR import matplotlib.pyplot as plt def mesh_grid(B, H, W): # mesh grid x_base = torch.arange(0, W).repeat(B, H, 1) # BHW y_base = torch.arange(0, H).repeat(B, W, 1).transpose(1, 2) # BHW base_grid = torch.stack([x_base, y_base], 1) # B2HW return base_grid def norm_grid(v_grid): _, _, H, W = v_grid.size() # scale grid to [-1,1] v_grid_norm = torch.zeros_like(v_grid) v_grid_norm[:, 0, :, :] = 2.0 * v_grid[:, 0, :, :] / (W - 1) - 1.0 v_grid_norm[:, 1, :, :] = 2.0 * v_grid[:, 1, :, :] / (H - 1) - 1.0 return v_grid_norm.permute(0, 2, 3, 1) # BHW2 \"\"\" :param data: unnormalized coordinates Bx2xHxW :return: Bx1xHxW \"\"\" B, _, H, W = data.size() # x = data[:, 0, :, :].view(B, -1).clamp(0, W - 1) # BxN (N=H*W) # y = data[:, 1, :, :].view(B, -1).clamp(0, H - 1) x = data[:, 0, :, :].view(B, -1) # BxN (N=H*W) y = data[:, 1, :, :].view(B, -1) # invalid = (x \u003c 0) | (x \u003e W - 1) | (y \u003c 0) | (y \u003e H - 1) # BxN # invalid = invalid.repeat([1, 4]) x1 = torch.floor(x) x_floor = x1.clamp(0, W - 1) y1 = torch.floor(y) y_floor = y1.clamp(0, H - 1) x0 = x1 + 1 x_ceil = x0.clamp(0, W - 1) y0 = y1 + 1 y_ceil = y0.clamp(0, H - 1) x_ceil_out = x0 != x_ceil y_ceil_out = y0 != y_ceil x_floor_out = x1 != x_floor y_floor_out = y1 != y_floor invalid = torch.cat([x_ceil_out | y_ceil_out, x_ceil_out | y_floor_out, x_floor_out | y_ceil_out, x_floor_out | y_floor_out], dim=1) # encode coordinates, since the scatter function can only index along one axis corresponding_map = torch.zeros(B, H * W).type_as(data) indices = torch.cat([x_ceil + y_ceil * W, x_ceil + y_floor * W, x_floor + y_ceil * W, x_floor + y_floor * W], 1).long() # BxN (N=4*H*W) values = torch.cat([(1 - torch.abs(x - x_ceil)) * (1 - torch.abs(y - y_ceil)), (1 - torch.abs(x - x_ceil)) * (1 - torch.abs(y - y_floor)), (1 - torch.abs(x - x_floor)) * (1 - torch.abs(y - y_ceil)), (1 - torch.abs(x - x_floor)) * (1 - torch.abs(y - y_floor))], 1) # values = torch.ones_like(values) values[invalid] = 0 corresponding_map.scatter_add_(1, indices, values) # decode coordinates corresponding_map = corresponding_map.view(B, H, W) return corresponding_map.unsqueeze(1) def flow_warp(x, flow12, pad='border', mode='bilinear'): B, _, H, W = x.size() base","date":"2022-05-17","objectID":"/blender-optical-flow-trap/:2:0","tags":["Blender"],"title":"Blender光流踩坑记录","uri":"/blender-optical-flow-trap/"},{"categories":["DataStructure"],"content":"本文主要介绍了线段树的基本操作，并以区间和为例对其更新和查询做了详细介绍。","date":"2022-03-11","objectID":"/introduce-to-segmenttree/","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/introduce-to-segmenttree/"},{"categories":["DataStructure"],"content":"写在前面 本文主要参考了 Pecco的知乎专栏，并在线段树概念介面增加了更多笔墨和证明，期望能给后续自身复习和他人学习带来更多帮助。由于个人疏于 C++ 语言，因此重新使用 Java 语言进行了实现。 ","date":"2022-03-11","objectID":"/introduce-to-segmenttree/:1:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/introduce-to-segmenttree/"},{"categories":["DataStructure"],"content":"线段树介绍 线段树（Segment Tree）是一种主要用于维护区间信息（要求满足结合律）的数据结构，它支持 $O(logn) $复杂度的区间修改和 $O(logn)$ 复杂度的区间查询。 线段树的每个节点都对应一条线段（区间）的某种运算结果（通常是乘积或加和，下面均以加和为例），其中根节点对应整个区间的和。对于某个非叶子节点 $node[left, right]$，其左右子节点对应区间可表示如下： $node.left[left, mid]$ $node.right[mid + 1, right]$ $mid = \\lfloor{(left + right) / 2)}\\rfloor{} \\ or \\ \\lfloor{(left + right + 1) / 2}\\rfloor{} - 1$ 为了更加直观，这里以区间 $[1, 5]$ 为例，对两种不同划分情况建立的线段树进行可视化： 方式一 方式二 可以看出线段树所有节点的左右子树高度差至多为1，因此线段树是一颗平衡二叉树。 接下来我们探讨线段树的存储方式。通常我们会将线段树存储在数组里，那么对于长度为 $n$ 的原数组，存储它的数组的大小应当为多少？ 答案是至少为 $2n - 1$，至多为 $4n - 5$。让我们来简单证明下。 对于一颗线段树，其叶子节点的数量为 $n$，因此其非叶子节点的数量为 $n - 1$，你可以很容易证明它，因为线段树的非叶子节点要么没有子节点，要么左右节点都不为空。所以存储线段树的数组大小至少为 $2n - 1$。 $$ n_0 + n_1 + n_2 = 2n_2 + n_1 + 1 -\u003e n_2 = n_0 - 1 = n - 1 $$ 但考虑如方式二种所示情况，因为使用数组存储，所以最后一层中为空的节点同样需要消耗数组空间。此时线段树的倒数第二层的节点数量为 $n - 2 + 1 = n - 1$，因此最后一层为空的节点数为 $2(n - 1) - 2 = 2n - 4$，所以整个数组的大小为 $2n - 4 + 2n - 1 = 4n - 5$。 而容易得知方式二就是最快的情况，所以一般建立线段树数组时需要开辟 $4n$ 的存储空间。 ","date":"2022-03-11","objectID":"/introduce-to-segmenttree/:2:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/introduce-to-segmenttree/"},{"categories":["DataStructure"],"content":"线段树的建立 那么如何从数组中建立一棵线段树？我们可以考虑递归地进行。假设输入数组为 $nums$， 长度为 $n$。 int[] tree = new int[4 * n]; // left, right为输入数组的左右区间点，p为待建立线段树的节点下标 public void build(int left, int right, int p){ // 叶子节点 if(left == right){ tree[p] = nums[left]; }else{ int mid = left + (right - left \u003e\u003e 1); // 先建立左右节点 build(left, mid, p * 2 + 1); build(mid + 1, right, p * 2 + 2); // 该节点的和等于左右节点的和 tree[p] = tree[p * 2 + 1] + tree[p * 2 + 2]; } } 这里是一张来自网上的 $gif$ 图，它描述了对 $[1,2,3,4,5]$ 建立线段树的过程： ","date":"2022-03-11","objectID":"/introduce-to-segmenttree/:3:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/introduce-to-segmenttree/"},{"categories":["DataStructure"],"content":"线段树的修改 仿照线段树的建立，我们也可以采用递归的方式进行修改，但这样的时间复杂度会比较高。而通常则会引入懒标记来加速这一过程，这也是线段树的精髓所在。使用懒标记后，对于恰好是线段树非叶子节点的那些区间，我们不再递归下去，而是打上一个标记，等到将来要用到它的子区间时，再向下传递。假设需要修改的区间为$[left, right]$，修改的量为 $d$，那么修改过程可以表示为： int[] mark = new int[4 * n]; public void update(int left, int right, int d){ update(left, right, d, 0, 0, n - 1); } // cLeft, cRight代表当前要修改的线段树区间 public void update(int left, int right, int d, int p, int cLeft, int cRight){ // 修改区间不包含线段树区间 if(left \u003e cRight || right \u003c cLeft){ return; }else if(cLeft \u003e= left \u0026\u0026 right \u003e= cRight){ // 修改区间完全覆盖线段树区间 tree[p] += (cRight - cLeft + 1) * d; // 直接修改对应区间值 if(cLeft != cRight){ // 并给非叶子节点打上标记 mark[p] += d; } }else{ // 修改区间与线段树区间存在重叠，则二分递归地修改 int mid = cLeft + (cRight - cLeft \u003e\u003e 1); mark[p * 2 + 1] += mark[p]; // 将当前节点的标记分发给其子节点 mark[p * 2 + 2] += mark[p]; tree[p * 2 + 1] += mark[p] * (mid - cLeft + 1); // 子节点的值叠加父节点的标记量 tree[p * 2 + 2] += mark[p] * (cRight - mid); mark[p] = 0; // 因为已经把懒标记给了子节点，所以本身的标记置0 } } 有同学可能会疑惑这个更新操作在修改区间完全覆盖线段树区间时没有更新整个线段树，但其实我们后续查询的过程中也会根据懒标记对节点值更新，所以不必担忧。 下面是一段为上面建立的线段树的区间 $[1,4]$ 加上 1 的过程： 实际上，对于上段更新部分 $18 \\to 22$ 部分的代码，由于后续查询部分同样要用到，所以通常会额外封装成另一个函数 $push_down$，其代码为： private void push_down(int p, int cLeft, int mid, int cRight){ mark[p * 2 + 1] += mark[p]; mark[p * 2 + 2] += mark[p]; tree[p * 2 + 1] += mark[p] * (mid - cLeft + 1); tree[p * 2 + 2] += mark[p] * (cRight - mid); mark[p] = 0; } ","date":"2022-03-11","objectID":"/introduce-to-segmenttree/:4:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/introduce-to-segmenttree/"},{"categories":["DataStructure"],"content":"线段树的查询 有了线段树的修改部分的经验，我们同样可以利用懒标记很快地写出查询部分的代码如下： public int query(int left, int right){ return query(left, right, 0, 0, n - 1); } private int query(int left, int right, int p, int cLeft, int cRight){ // 查询区间不包含线段树区间 if(left \u003e cRight || right \u003c cLeft){ return 0; }else if(cLeft \u003e= left \u0026\u0026 cRight \u003c= right){ // 查询区间恰好覆盖线段树区间 return tree[p]; }else{ // 查询区间与线段树区间存在重叠，则二分查询，同时记得跟新懒标记 int mid = cLeft + (cRight - cLeft \u003e\u003e\u003e 1); push_down(p, cLeft, mid, cRight); return query(left, right, p * 2 + 1, cLeft, mid) + query(left, right, p * 2 + 2, mid + 1, cRight); } } ","date":"2022-03-11","objectID":"/introduce-to-segmenttree/:5:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/introduce-to-segmenttree/"},{"categories":["DataStructure"],"content":"结语 本文仅介绍了最基本的线段树用法，其实线段树的题目千奇百怪，而且技巧极多。在维护不同的信息时，需要注意是否需要乘区间长度、不同的标记之间是否相互影响等。下面附上用于区间和的线段树模板： class SegmentTree { private final int[] tree; private final int[] mark; private final int n; public SegmentTree(int[] nums){ n = nums.length; tree = new int[n \u003c\u003c 2]; Arrays.fill(tree, Integer.MIN_VALUE); build(nums, 0, nums.length - 1, 0); mark = new int[n \u003c\u003c 2]; } private void build(int[] nums, int left, int right, int p){ if(left == right){ tree[p] = nums[left]; }else{ int mid = (left + right) / 2; build(nums, left, mid, p * 2 + 1); build(nums, mid + 1, right, p * 2 + 2); tree[p] = tree[p * 2 + 1] + tree[p * 2 + 2]; } } public void update(int left, int right, int d){ update(left, right, d, 0, 0, n - 1); } private void update(int left, int right, int d, int p, int cLeft, int cRight){ if(cLeft \u003e right || cRight \u003c left){ return; }else if(cLeft \u003e= left \u0026\u0026 cRight \u003c= right){ tree[p] += (cRight - cLeft + 1) * d; if(cLeft \u003c cRight){ mark[p] += 1; } }else{ int mid = cLeft + (cRight - cLeft \u003e\u003e\u003e 1); push_down(p, cLeft, mid, cRight); update(left, right, d, p * 2 + 1, cLeft, mid); update(left, right, d, p * 2 + 2, mid + 1, cRight); tree[p] = tree[p * 2 + 1] + tree[p * 2 + 2]; } } public int query(int left, int right){ return query(left, right, 0, 0, n - 1); } private int query(int left, int right, int p, int cLeft, int cRight){ if(left \u003e cRight || right \u003c cLeft){ return 0; }else if(cLeft \u003e= left \u0026\u0026 cRight \u003c= right){ return tree[p]; }else{ int mid = cLeft + (cRight - cLeft \u003e\u003e\u003e 1); push_down(p, cLeft, mid, cRight); return query(left, right, p * 2 + 1, cLeft, mid) + query(left, right, p * 2 + 2, mid + 1, cRight); } } private void push_down(int p, int cLeft, int mid, int cRight){ mark[p * 2 + 1] += mark[p]; mark[p * 2 + 2] += mark[p]; tree[p * 2 + 1] += mark[p] * (mid - cLeft + 1); tree[p * 2 + 2] += mark[p] * (cRight - mid); mark[p] = 0; } } 实际上线段树还可以维护区间最值、区间 $gcd$ 等等，操作除了区间加也可以是区间乘、区间赋值，了解原理后很容易改。 ","date":"2022-03-11","objectID":"/introduce-to-segmenttree/:6:0","tags":["SegmentTree","DataStructure"],"title":"初识线段树","uri":"/introduce-to-segmenttree/"},{"categories":null,"content":"关于我 一个普通的小镇青年，有幸拥有普通的智力和普通而温馨的家庭，互联网萌新，业余日语翻译。 ","date":"2022-03-08","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"关于本站 不求成为多有含量的技术博客，仅是分享自身的学习经验，期望能解答部分你遇到的难题。 ","date":"2022-03-08","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Course"],"content":"本文简要介绍了如何利用 GitHub Actions 来自动化 Hugo 博客的部署。","date":"2022-03-08","objectID":"/use-github-actions-for-automating-hugo-blog-deployment/","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/use-github-actions-for-automating-hugo-blog-deployment/"},{"categories":["Course"],"content":"前置准备 在部署 Hugo 博客前，我们首先需要有一个 Hugo 博客，因此需要预先安装 Hugo、 Go（Go 是 Hugo 的运行依赖）和 Git（用于版本管理，你也可以选择其他 SVN）。 ","date":"2022-03-08","objectID":"/use-github-actions-for-automating-hugo-blog-deployment/:1:0","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/use-github-actions-for-automating-hugo-blog-deployment/"},{"categories":["Course"],"content":"Go 和 Git 的安装 Go官网 和 Git官网下载安装包后一直点下一步即可。 ","date":"2022-03-08","objectID":"/use-github-actions-for-automating-hugo-blog-deployment/:1:1","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/use-github-actions-for-automating-hugo-blog-deployment/"},{"categories":["Course"],"content":"Hugo 的安装 官方发布处选择适合你电脑的版本下载，需要注意的是有些 Hugo 主题需要 Hugo_extended 才能使用。 对于 Windows 用户，下载下来的压缩包解压后仅包含 License 文件、ReadMe 和一个可执行文件。为了方便起见，我们可以将其所在的文件夹路径添加系统变量的 Path 变量中，这样即可直接在 cmd 中使用 hugo xxx 命令。 ","date":"2022-03-08","objectID":"/use-github-actions-for-automating-hugo-blog-deployment/:1:2","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/use-github-actions-for-automating-hugo-blog-deployment/"},{"categories":["Course"],"content":"搭建博客 ","date":"2022-03-08","objectID":"/use-github-actions-for-automating-hugo-blog-deployment/:2:0","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/use-github-actions-for-automating-hugo-blog-deployment/"},{"categories":["Course"],"content":"Hugo 简单命令 首先介绍几个简单的 Hugo 命令，更多信息可参考官方文档。 hugo new site dst 该命令会在 dst 处新建一个 Hugo 博客工程文件，dst 为 . 时则会在当前路径新建。需要注意的是，当 dst 对应路径的文件夹已存在，Hugo 会报错并提示你在命令中增加 -force 参数来强制创建，此时按照提示添加即可创建成功。新建的 Hugo 博客工程文件夹下应该类似下图： 刚完成配置的Hugo文件夹 ├── config.toml 总配置文件，可以在里面更改各类配置 ├── archetypes 文章原型 │ └── default.md ├── content 存放文章内容的文件夹 ├── data ├── layouts 布局相关文件 ├── static 用于存放你在 content 中的文章会用到的图片等资料 ├── public 渲染出来的文章会放在该文件夹下 └── themes 用于存放 Hugo 的主题 hugo new dst 该命令会在 content 文件夹下创建 dst 文章，一般该文件应当以 .md 结尾，同时根据语言类型在正式文件名和后缀名间加上语言代号以方便后期管理，例如 post.zh-cn.md。dst 也可以是多级相对路径，例如 posts/post_1.zh-cn.md，此时会在 content/posts 路径下创建 post_1.zh-cn.md。 hugo server -D 该命令会启动服务器，并使你能在本地预览 Hugo 博客，预览地址默认为 localhost:1313。 hugo 该命令会在 public 文件夹下生成可部署的静态网页文件。 ","date":"2022-03-08","objectID":"/use-github-actions-for-automating-hugo-blog-deployment/:2:1","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/use-github-actions-for-automating-hugo-blog-deployment/"},{"categories":["Course"],"content":"引入 Hugo 主题 假设你已经搭建了一个 Hugo 博客工程文件，现在我们可以引入 Hugo 主题来简化后续网站的风格搭建工作（当然你是大佬或者你想自己配置风格除外）。Hugo 主题可以在这个网站找到，你可以在其中挑选一个你喜欢的，我这里使用的是 FixIt，同时也推荐几个个人认为比较适合的主题：Clarity、Even、Meme、Octopress。 当你挑选好主题后，你可以直接将其克隆到你的 themes 文件下，或者初始化你的项目为 git 仓库，并且把主题仓库作为你的网站目录的子模块。 git init git submodule add https://github.com/Lruihao/FixIt.git themes/FixIt 由于后续我们希望使用 Github Action 来便捷部署 Hugo 博客，因此这里需要使用第二种方法。下载完主题后，你应当根据主题中的 ReadMe 或相关文档配置你的 config.toml 文件，另外为了后续部署，你应当将你的主题作为一个子模块挂载到你的博客并修改 baseURL，具体来说是应当在你的 config.toml 文件中添加修改： baseURL = \"xxx\" # 后续你的博客的地址 [module] [[module.imports]] # xxx 为 themes 文件下你的主题文件夹的名称 path = 'xxx' 另外需要注意的是，如果该行配置应当写在 theme=xxx 配置前，同时如果该行写在 defaultContentLanguage=xxx 前，则会使得defaultContentLanguage=xxx配置失效而导致一些莫名其妙的错误。 ","date":"2022-03-08","objectID":"/use-github-actions-for-automating-hugo-blog-deployment/:2:2","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/use-github-actions-for-automating-hugo-blog-deployment/"},{"categories":["Course"],"content":"GitHub 配置 首先说说我们自动化部署的最终目的，即希望在本地预览无误后，直接推送工程文件到 Github 的某个工程仓库后，我们的主页仓库（即https://github.com/xxx/xxx.github.io ）就会自动更新，使得访问 xxx.github.io 或者你配置的域名时得到的就是更新的内容，而不用每次手动将工程文件下的public 文件夹 push 到我们的主页仓库。 为此我们需要使用 Github Actions 来完成这一过程，它可以监听围绕代码仓库管理的各种事件，比如 push 和 pull_request 事件，触发提前计划好的一系列步骤，即工作流。这些步骤用 YAML 文档记录。触发工作流包括了构建和测试。这些工作流可以在 GitHub 的服务器上执行，开发者也可以在自己的服务器响应从 GitHub 触发的事件来执行工作流。 ","date":"2022-03-08","objectID":"/use-github-actions-for-automating-hugo-blog-deployment/:3:0","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/use-github-actions-for-automating-hugo-blog-deployment/"},{"categories":["Course"],"content":"创建并配置 GitHub 工程仓库 首先创建一个私有的 Github 仓库用于存储工程文件，而后在该仓库页 setting -\u003e Secrets -\u003e Actions 下通过 new repository secret 创建一个新的动作密钥，并且注意一定要勾选 Allow write access。密钥可以采用 ssh-keygen 命令生成密钥对，并将私钥填入，下面是参考密钥对生成代码。另外并假设这里你创建的动作密钥名称为 ACTIONS_DEPLOY_KEY。 ssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\" # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key) ","date":"2022-03-08","objectID":"/use-github-actions-for-automating-hugo-blog-deployment/:3:1","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/use-github-actions-for-automating-hugo-blog-deployment/"},{"categories":["Course"],"content":"创建并配置 GitHub 主页仓库 而后创建你的主页仓库，它应当是公开的，同时其仓库名应当是 xxx.github.io，其中 xxx 为你的 Github 用户名。在该仓库页 setting -\u003e Pages 你可以看到你的 Github Page 地址，同时下面的 Custom Domain 可以用以自定义地址的域名（你需要先购买一个并配好相关设置）。然后在 Deploy keys -\u003e Add deploy key 中添加对应的部署密钥，其值为先前 ssh-keygen 生成的公钥。 ","date":"2022-03-08","objectID":"/use-github-actions-for-automating-hugo-blog-deployment/:3:2","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/use-github-actions-for-automating-hugo-blog-deployment/"},{"categories":["Course"],"content":"创建并配置 GitHub Actions 在工程仓库对应的本地文件夹下，创建.github/workflows/github-pages.yml 文件，文件名你可以自定义，然后修改文件内容如下： # This is a basic workflow to help you get started with Actionsname:Github Pages# Controls when the workflow will runon:# Triggers the workflow on push or pull request events but only for the main branchpush:branches:[master ]pull_request:branches:# Allows you to run this workflow manually from the Actions tabworkflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:# This workflow contains a single job called \"build\"build:# The type of runner that the job will run onruns-on:ubuntu-latest# Steps represent a sequence of tasks that will be executed as part of the jobsteps:# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it- uses:actions/checkout@v2# 后续版本可能有更新，请选择合适的版本with:submodules:true# 根据你是否添加子模块而定fetch-depth:0- name:Setup Hugouses:peaceiris/actions-hugo@v2# 后续版本可能有更新，请选择合适的版本with:hugo-version:'0.93.2'# 根据你的 Hugo 版本而定extended:true# 根据你的 Hugo 版本而定- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3# 后续版本可能有更新，请选择合适的版本with:DEPLOY_KEY:${{ secrets.ACTIONS_DEPLOY_KEY }}# 这里对应上面创建的动作密钥名称EXTERNAL_REPOSITORY:xxx/xxx.github.io# 部署的主页仓库PUBLISH_BRANCH:masterPUBLISH_DIR:./public 而后通过 git 或其他工具将该工程项目 push 到 对应GitHub 仓库中，等待一小段时间再次访问 xxx.github.io，即会发现对应的网页已经自动发生修改。如果发生错误，你会收到一封通知邮件，你可以通过 Actions 进入对应的 workflow 查找错误原因，并自行 debug 或通过 谷歌 和 百度 搜索相关经验。后续我们要对博客进行修改，也只需要修改工程文件然后 push 即可。 ","date":"2022-03-08","objectID":"/use-github-actions-for-automating-hugo-blog-deployment/:3:3","tags":["Hugo","GitHub Actions"],"title":"利用 GitHub Actions 来自动化 Hugo 博客的部署","uri":"/use-github-actions-for-automating-hugo-blog-deployment/"},{"categories":null,"content":"离线 - ","date":"0001-01-01","objectID":"/offline/","tags":null,"title":"","uri":"/offline/"}]